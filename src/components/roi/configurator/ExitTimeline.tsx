import { useMemo, useRef, useCallback, useState } from "react";
import { X, AlertTriangle } from "lucide-react";
import { getMonthWhenThresholdMet } from "../constructionProgress";
import { OIInputs } from "../useOICalculations";

interface ExitPoint {
  id: string;
  label: string;
  monthsFromBooking: number;
  isAutoGenerated: boolean;
  exitValue: number;
  appreciationPercent: number;
}

interface ExitTimelineProps {
  exits: ExitPoint[];
  totalMonths: number;
  bookingDate: Date;
  currency: string;
  minimumThreshold?: number;
  onAddExit?: (monthsFromBooking: number) => void;
  onRemoveExit?: (exitId: string) => void;
  onMoveExit?: (exitId: string, newMonth: number) => void;
  readOnly?: boolean;
  inputs?: OIInputs; // For calculating when threshold is met
  basePrice?: number;
}

export const ExitTimeline = ({ 
  exits, 
  totalMonths, 
  bookingDate, 
  currency, 
  minimumThreshold = 30, 
  onAddExit,
  onRemoveExit,
  onMoveExit,
  readOnly = false,
  inputs,
  basePrice,
}: ExitTimelineProps) => {
  const timelineRef = useRef<HTMLDivElement>(null);
  const [draggingId, setDraggingId] = useState<string | null>(null);
  const [dragMonth, setDragMonth] = useState<number | null>(null);
  const [hoveredId, setHoveredId] = useState<string | null>(null);

  // Calculate threshold position: the month when payment plan naturally reaches threshold
  const { thresholdPosition, thresholdMonth } = useMemo(() => {
    if (inputs && basePrice) {
      const month = getMonthWhenThresholdMet(inputs, totalMonths, basePrice);
      return {
        thresholdPosition: (month / totalMonths) * 100,
        thresholdMonth: month,
      };
    }
    // Fallback: use threshold as direct percentage of timeline
    const fallbackMonth = Math.round((minimumThreshold / 100) * totalMonths);
    return {
      thresholdPosition: minimumThreshold,
      thresholdMonth: fallbackMonth,
    };
  }, [inputs, basePrice, totalMonths, minimumThreshold]);

  // Generate month tick marks
  const monthTicks = useMemo(() => {
    const ticks = [];
    for (let month = 0; month <= totalMonths; month++) {
      const position = (month / totalMonths) * 100;
      const isHandover = month === totalMonths;
      const showLabel = month === 0 || isHandover || month % 6 === 0;
      ticks.push({ month, position, showLabel, isHandover });
    }
    return ticks;
  }, [totalMonths]);

  // Calculate smart label positions to avoid overlap with compact stacking
  const timelineMarkers = useMemo(() => {
    const sortedExits = [...exits].sort((a, b) => a.monthsFromBooking - b.monthsFromBooking);
    
    // First pass: calculate basic marker data
    const basicMarkers = sortedExits.map((exit) => {
      const position = (exit.monthsFromBooking / totalMonths) * 100;
      const date = (() => {
        const d = new Date(bookingDate);
        d.setMonth(d.getMonth() + exit.monthsFromBooking);
        return d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
      })();
      // Exit meets threshold if it's at or after the threshold month
      const meetsThreshold = exit.monthsFromBooking >= thresholdMonth;
      
      return {
        ...exit,
        position,
        date,
        meetsThreshold,
        labelLevel: 0,
      };
    });
    
    // Second pass: assign label levels to avoid overlap
    const markersWithLevels = basicMarkers.map((marker, index) => {
      let labelLevel = 0;
      
      // Check distance to ALL previous markers to assign proper level
      for (let i = 0; i < index; i++) {
        const prevMarker = basicMarkers[i];
        const distance = marker.position - prevMarker.position;
        
        // Very close (within 8%) - need maximum stacking
        if (distance < 8) {
          labelLevel = Math.max(labelLevel, 2);
        }
        // Moderately close (8-15%) - need some stacking  
        else if (distance < 15) {
          // Only stack if previous marker would overlap
          const prevMarkerLevel = markersWithLevels[i]?.labelLevel || 0;
          if (prevMarkerLevel === labelLevel) {
            labelLevel = Math.max(labelLevel, 1);
          }
        }
      }
      
      // Ensure alternating levels for very close markers
      if (index > 0) {
        const prevMarker = basicMarkers[index - 1];
        const prevLevel = markersWithLevels[index - 1]?.labelLevel || 0;
        if (marker.position - prevMarker.position < 10 && labelLevel === prevLevel) {
          labelLevel = (prevLevel + 1) % 3;
        }
      }
      
      return {
        ...marker,
        labelLevel,
      };
    });

    return markersWithLevels;
  }, [exits, totalMonths, bookingDate, thresholdMonth]);

  const getMonthFromPosition = useCallback((clientX: number): number => {
    if (!timelineRef.current) return 0;
    const rect = timelineRef.current.getBoundingClientRect();
    const percentage = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
    return Math.round((percentage / 100) * totalMonths);
  }, [totalMonths]);

  const handleMouseDown = useCallback((e: React.MouseEvent, exitId: string, currentMonth: number) => {
    if (readOnly) return;
    e.preventDefault();
    e.stopPropagation();
    setDraggingId(exitId);
    setDragMonth(currentMonth);
  }, [readOnly]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!draggingId) return;
    const month = getMonthFromPosition(e.clientX);
    if (month > 0 && month < totalMonths) {
      setDragMonth(month);
    }
  }, [draggingId, getMonthFromPosition, totalMonths]);

  const handleMouseUp = useCallback(() => {
    if (draggingId && dragMonth !== null && onMoveExit) {
      const originalExit = exits.find(e => e.id === draggingId);
      if (originalExit && originalExit.monthsFromBooking !== dragMonth) {
        onMoveExit(draggingId, dragMonth);
      }
    }
    setDraggingId(null);
    setDragMonth(null);
  }, [draggingId, dragMonth, exits, onMoveExit]);

  const handleTimelineClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!onAddExit || readOnly || draggingId) return;
    
    const month = getMonthFromPosition(e.clientX);
    
    // Don't add if too close to existing exit (within 2 months) or if month is 0 or handover
    const tooClose = exits.some(exit => Math.abs(exit.monthsFromBooking - month) < 2);
    
    if (!tooClose && month > 0 && month < totalMonths) {
      onAddExit(month);
    }
  }, [onAddExit, readOnly, draggingId, getMonthFromPosition, totalMonths, exits]);

  const handleRemoveClick = useCallback((e: React.MouseEvent, exitId: string) => {
    e.preventDefault();
    e.stopPropagation();
    if (onRemoveExit) {
      onRemoveExit(exitId);
    }
  }, [onRemoveExit]);

  const getLabelTopOffset = (level: number) => {
    const offsets = ['top-6', 'top-12', 'top-18'];
    return offsets[level] || offsets[0];
  };

  return (
    <div 
      className="p-4 bg-theme-bg-alt rounded-lg border border-theme-border select-none"
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
    >
      <div className="flex items-center justify-between mb-2">
        <div className="text-[10px] text-theme-text-muted uppercase tracking-wider font-medium">Exit Timeline</div>
        {!readOnly && onAddExit && (
          <div className="text-[10px] text-theme-accent/70">Click timeline to add exit</div>
        )}
      </div>
      
      {/* Month ruler with tick marks */}
      <div className="relative mb-2">
        <div className="flex justify-between h-4">
          {monthTicks.map(tick => (
            <div 
              key={tick.month}
              className="relative flex flex-col items-center"
              style={{ 
                position: 'absolute', 
                left: `${tick.position}%`, 
                transform: 'translateX(-50%)',
              }}
            >
              <div className={`w-px ${tick.isHandover || tick.month === 0 ? 'h-3 bg-theme-text-muted' : tick.showLabel ? 'h-2 bg-theme-text-muted/60' : 'h-1.5 bg-theme-text-muted/30'}`} />
              {tick.showLabel && (
                <span className="text-[8px] text-theme-text-muted/80 mt-0.5 whitespace-nowrap">
                  {tick.month === 0 ? '0' : tick.isHandover ? `${tick.month}mo` : `${tick.month}`}
                </span>
              )}
            </div>
          ))}
        </div>
      </div>
      
      {/* Timeline bar - clickable */}
      <div 
        ref={timelineRef}
        onClick={handleTimelineClick}
        className={`relative h-4 bg-theme-card rounded-full mb-20 ${!readOnly && onAddExit ? 'cursor-crosshair hover:bg-theme-card-alt transition-colors' : ''}`}
      >
        {/* Progress gradient */}
        <div 
          className="absolute inset-y-0 left-0 rounded-full pointer-events-none"
          style={{
            width: '100%',
            background: 'linear-gradient(90deg, hsl(var(--theme-accent)) 0%, hsl(142 71% 45%) 50%, hsl(221 83% 53%) 100%)',
            opacity: 0.2,
          }}
        />
        
        {/* Threshold indicator line */}
        <div
          className="absolute top-1/2 -translate-y-1/2 h-8 w-0.5 pointer-events-none"
          style={{
            left: `${thresholdPosition}%`,
            background:
              "repeating-linear-gradient(to bottom, hsl(var(--theme-accent)) 0, hsl(var(--theme-accent)) 2px, transparent 2px, transparent 4px)",
          }}
        />
        <div
          className="absolute -top-7 text-[9px] whitespace-nowrap pointer-events-none font-medium"
          style={{ left: `${thresholdPosition}%`, transform: "translateX(-50%)" }}
        >
          <span className="px-1.5 py-0.5 rounded-md bg-theme-bg-alt border border-theme-border text-theme-accent flex items-center gap-1">
            <AlertTriangle className="w-2.5 h-2.5" />
            {minimumThreshold}% @ mo {thresholdMonth}
          </span>
        </div>

        {/* Exit markers */}
        {timelineMarkers.map((marker) => {
          const isDragging = draggingId === marker.id;
          const currentPosition = isDragging && dragMonth !== null 
            ? (dragMonth / totalMonths) * 100 
            : marker.position;
          const displayMonth = isDragging && dragMonth !== null ? dragMonth : marker.monthsFromBooking;
          const isHovered = hoveredId === marker.id;
          const canInteract = !readOnly;
          
          return (
            <div
              key={marker.id}
              className={`absolute top-1/2 -translate-y-1/2 flex flex-col items-center ${isDragging ? 'z-20' : 'z-10'}`}
              style={{ left: `${currentPosition}%`, transform: 'translate(-50%, -50%)' }}
              onMouseEnter={() => setHoveredId(marker.id)}
              onMouseLeave={() => setHoveredId(null)}
            >
              {/* Marker dot - draggable */}
              <div 
                onMouseDown={(e) => handleMouseDown(e, marker.id, marker.monthsFromBooking)}
                 className={`relative w-5 h-5 rounded-full border-2 shadow-lg transition-all ${
                   !marker.meetsThreshold
                     ? 'bg-destructive/40 border-destructive/50'
                     : 'bg-theme-accent border-theme-accent/80'
                 } ${canInteract ? 'cursor-grab active:cursor-grabbing hover:scale-110' : ''} ${isDragging ? 'scale-125 ring-2 ring-theme-accent/50' : ''}`}
               >
                 {/* Delete button on hover */}
                 {canInteract && isHovered && !isDragging && onRemoveExit && (
                   <button
                     type="button"
                     onMouseDown={(e) => {
                       e.preventDefault();
                       e.stopPropagation();
                     }}
                     onClick={(e) => handleRemoveClick(e, marker.id)}
                     className="absolute -top-1 -right-1 w-4 h-4 bg-destructive text-destructive-foreground rounded-full flex items-center justify-center hover:opacity-90 transition-opacity shadow-md pointer-events-auto"
                   >
                     <X className="w-2.5 h-2.5" />
                   </button>
                 )}
               </div>

              {/* Label below - positioned to avoid overlap with compact stacking */}
              <div 
                className={`absolute whitespace-nowrap text-center pointer-events-none transition-all ${
                  marker.labelLevel === 0 ? 'top-6' : marker.labelLevel === 1 ? 'top-[52px]' : 'top-[76px]'
                }`}
              >
                {/* Connecting line for offset labels */}
                {marker.labelLevel > 0 && (
                  <div 
                    className="absolute left-1/2 -translate-x-1/2 w-px bg-theme-text-muted/30"
                    style={{ 
                      top: marker.labelLevel === 1 ? '-28px' : '-52px',
                      height: marker.labelLevel === 1 ? '28px' : '52px',
                    }}
                  />
                )}
                {/* Compact stacked label */}
                <div className={`px-1 py-0.5 rounded ${marker.labelLevel > 0 ? 'bg-theme-bg-alt/80' : ''}`}>
                  <div className={`text-[10px] font-semibold leading-tight ${
                    isDragging ? 'text-theme-accent' : 
                    !marker.meetsThreshold ? 'text-red-400' : 'text-theme-text'
                  }`}>
                    {displayMonth}mo
                  </div>
                  <div className="text-[8px] text-theme-text-muted leading-tight">{marker.date}</div>
                  <div className={`text-[9px] font-mono font-medium leading-tight ${!marker.meetsThreshold ? 'text-red-400' : 'text-green-400'}`}>
                    +{marker.appreciationPercent.toFixed(0)}%
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
      
      {/* Start and end labels */}
      <div className="flex justify-between text-[10px] text-theme-text-muted mt-2">
        <span>Booking</span>
        <span>Handover ({totalMonths}mo)</span>
      </div>
      
      {/* Legend */}
      <div className="flex items-center justify-center gap-4 mt-3 pt-2 border-t border-theme-border/50">
        <div className="flex items-center gap-1.5">
          <div className="w-2.5 h-2.5 rounded-full bg-theme-accent" />
          <span className="text-[9px] text-theme-text-muted">Exit Point</span>
        </div>
        <div className="flex items-center gap-1.5">
          <div className="w-2.5 h-2.5 rounded-full bg-red-500/60" />
          <span className="text-[9px] text-theme-text-muted">Below min threshold</span>
        </div>
        {!readOnly && (
          <div className="flex items-center gap-1.5">
            <span className="text-[9px] text-theme-text-muted/60">â€¢ Drag to move</span>
          </div>
        )}
      </div>
    </div>
  );
};
